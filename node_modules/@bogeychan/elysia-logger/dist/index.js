import { pino } from "pino";
import { Elysia } from "elysia";
/**
 * If you call one of the derived methods of this plugin (such as: ctx.log.info(object)) with a request or context object,
 * these formatters and serializers ensure that not everything ends up in the log output.
 *
 * You can replace them altogether by providing your own via the plugin-options to manipulate the output.
 *
 * I highly recommend to read the [Pino documentation](https://getpino.io/#/docs/api?id=options) yourself to learn about additional options.
 */
import { formatters, serializers } from "./config/index.js";
export function logger(options = {}) {
    return plugin(options);
}
export function fileLogger(options) {
    return plugin(options);
}
/**
 * Create a logger instance like the plugin.
 */
export function createPinoLogger(options = {}) {
    const log = createPinoLoggerInternal(options);
    // @ts-ignore
    log.into = into.bind(log);
    return log;
}
function createPinoLoggerInternal(options) {
    options.level ??= "info";
    options.formatters ??= formatters;
    options.serializers ??= serializers;
    const streamOptions = options;
    if ("file" in options) {
        streamOptions.stream = pino.destination(options.file);
        delete options.file;
    }
    return pino(options, streamOptions.stream);
}
export function wrap(logger, options = {}) {
    return into.bind(logger)(options);
}
function into(options = {}) {
    const useLevel = options.useLevel ?? "info";
    const autoLogging = options.autoLogging ?? true;
    delete options.autoLogging;
    const getLog = (ctx) => {
        return typeof options.customProps === "function"
            ? this.child(options.customProps(ctx))
            : this;
    };
    let app = new Elysia({
        name: "@bogeychan/elysia-logger",
        seed: options,
    }).derive({ as: "global" }, (ctx) => {
        const loggerCtx = ctx;
        loggerCtx.isError = false;
        return { log: getLog(loggerCtx) };
    });
    if (autoLogging) {
        return app
            .onRequest((ctx) => {
            ctx.store = { ...ctx.store, startTime: performance.now() };
        })
            .onAfterResponse((ctx) => {
            const loggerCtx = ctx;
            loggerCtx.isError = false;
            const log = getLog(loggerCtx);
            if (log.level == "silent") {
                return;
            }
            if (typeof autoLogging == "object" && autoLogging.ignore(loggerCtx)) {
                return;
            }
            ctx.store.startTime ??= 0;
            ctx.store.endTime = performance.now();
            ctx.store.responseTime = ctx.store.endTime - ctx.store.startTime;
            log[useLevel](ctx);
        })
            .onError((ctx) => {
            const loggerCtx = ctx;
            loggerCtx.isError = true;
            const log = getLog(loggerCtx);
            if (log.level == "silent") {
                return;
            }
            if (typeof autoLogging == "object" && autoLogging.ignore(loggerCtx)) {
                return;
            }
            if (ctx.code === "NOT_FOUND") {
                log[useLevel](ctx);
            }
            else {
                log.error(ctx);
            }
        })
            .as("global");
    }
    return app;
}
const plugin = (options) => into.bind(createPinoLoggerInternal(options))(options);
export * from "./config/index.js";
export { pino } from "pino";
